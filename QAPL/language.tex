\documentclass{article}

\usepackage{xcolor}
\usepackage{mathtools}
\usepackage{stmaryrd}
\usepackage{amssymb,amsmath}
\usepackage{todonotes}
\usepackage{amsthm}
\usepackage{mathrsfs}

\title{A Language for Adaptive Behaviors}
\author{Marco Tinacci}
\date{\today}

% ~~~~~~~~~~~~~~~~~~~~~~~~~ %
% ~~~ THEOREMS SETTINGS ~~~ %
% ~~~~~~~~~~~~~~~~~~~~~~~~~ %

\newtheorem{defn}{Definition}
\theoremstyle{remark}
\newtheorem{example}{Example}

\begin{document}
\maketitle

\todo[inline]{notations (distribution)}

\section{The proposed language} % (fold)
\label{sec:introduction}

The structure of the proposed language naturally extends the \texttt{AbC} calculus
\todo{citare} 
suitably reduced in terms of operators and expressiveness. We consider \texttt{AbC} since it offers large expressiveness for defining communicating agents in an attribute-oriented fashion.
\todo{Precisare cosa si taglia e perche'} 
We cut out communication of parameters that has been replaced by action labels to ease the understanding and to focus on the new features that the language offers.

The language is intended for modeling adaptive agents that can interact with the surrounding environment through sensors and actuators. Main concepts of this language are \emph{components}, that describe the agents that compose the whole system, and \emph{processes}, that describe components' behaviors.

The original contribution of this language with respect to the state of the art, is the possibility to explicitly define an asymmetric relation ``x observe y'' using the \emph{observe} operator $\triangleright^f$. In this way we say that component $x$ is observing component $y$, in particular, using the filter function $f$, we can specify what can be perceived from $y$. Moreover the language gives the possibility to specify uncertainties on progression of processes and perception of observed signals from the considered environment.

We give a semantics in terms of partially observable models\todo{citare POMDP}, in particular we consider nondeterminism, probabilistic behaviors and probabilistic perceptions. Since one of our target is computing schedulers for agents in order to reach a given target, the \emph{hierarchical structure} imposed by operator $\triangleright^f$ allows a gradual resolution of the problem. This kind of compositional approach helps to avoid the state space explosion, indeed once a scheduler is computed for a small subproblem it can be applied reducing the dimension of the model, that also represents the environment of an higher problem.

% section introduction (end)

\subsection*{Syntax} % (fold)
\label{sec:syntax}

The syntax of the language is reported in Table~\ref{tab:syntax}, where syntactical categories of \emph{components} $C$, \emph{processes} $P$, \emph{process actions} $\alpha$, \emph{predicates} $\Pi$ and \emph{expressions} $E$ are described. 
\begin{table}[htbp]
$$
\begin{array}{lll}
	C &::=& \Gamma : P \ |\ C_1||C_2 \ |\ C_1 \triangleright^f C_2 \\[0.5em]
	P &::=& \mathbf{0} \ |\ \Sigma_{i \in I} PP_i \ |\ K \\[0.5em]
	%P &::=& \mathbf{0} \ |\ \langle \Pi \rangle\ \alpha \bigoplus_{i \in I} p_i : P_i \ |\ \Sigma_{i \in I} P_i \ |\ K \\[0.5em]
	PP &::=& \langle \Pi \rangle\ \alpha \bigoplus_{i \in I} p_i : P_i \\[0.5em]
	\alpha &::=& (a) [\sigma] \ |\ {(a) @ \Pi [\sigma]} \\[0.5em]
	\Pi &::=& \texttt{tt} \ |\ E_1 \bowtie E_2 \ |\ \Pi_1 \wedge \Pi_2 \ |\ \dots \\[0.5em]
	E &::=& v \ |\ n \ |\ this.n \ |\ \dots \\
\end{array}
$$
\label{tab:syntax}
\caption{The syntax of the language}
\end{table}

% components
We describe now the intuitive meaning of each syntactical element, we use $Proc$ and $Comp$ to denote respectively the set of every process and every component generated by the proper syntactic category. Components ($C$) is a process $P$ paired with its \emph{attribute environment} $\Gamma$ when it is expressed as $\Gamma : P$. The attribute environment is a partial function $\Gamma : \mathcal{A} \hookrightarrow \mathcal{V}$ that maps attribute names $\mathcal{A}$ into values $\mathcal{V}$. A component can also be a \emph{parallel composition} of other components $C_1 || C_2$ or a component that observe another component $C_1 \triangleright^f C_2$. The \emph{filter function} $f : Comp \rightarrow (\mathcal{A} \hookrightarrow \mathcal{V}) $ is a function that return properly filtered information of the observed component $C_2$.
\\

% processes
A process can assume one of the following structures: the \emph{inactive process} $\mathbf{0}$, the \emph{action-prefixed probabilistic process} \todo{aggiornare a PP} $\langle\Pi\rangle \alpha\bigoplus_{i \in I} p_i : P_i$, the \emph{nondeterministic choice} $\Sigma_{i \in I} P_i$ and the \emph{recursive call} $K$.
Action-prefixing is extended with a probabilistic evolution of the process, $p_i$ is the probability that the process will evolve as $P_i$ once action $\alpha$ is executed. Action-prefixing also integrates a predicate $\Pi$ inherited from the original awareness process of AbC, it works as a guard that can disable the execution of the action $\alpha$ and the probabilistic evolution if it is not satisfied under the attribute environment $\Gamma$. When the guard is satisfied the execution of $\alpha$ and the following process are enabled and aware of $\Pi$. To ease the notation we can write $\langle\Pi\rangle \alpha (P_1 \oplus_{p_2} P_2)$ when $I = \{1,2\}$ and $p_1 = 1-p_2$.
In the same way we can simplify the general notation of the non-deterministic choice $\Sigma_{i \in \{1,2\}} P_i$ with $P_1 + P_2$. Finally we use $K \triangleq P$ to define a process $K$ that behaves like $P$ and to enable recursive calls.
\\

\todo[inline]{actions, predicates, expressions, examples ...}

\paragraph{Well-formedness} % (fold)
\label{par:well_formedness}

To ease the understanding and the complexity of the language we give a ``well-formedness'' definition of terms generated by the syntax. 
\begin{defn}[Well-formed terms]\label{def:wellformedness}
%Finally we assume that each process has a unique definition $K \triangleq P$ to avoid ambiguities in the recursive calls.
\begin{enumerate} A term generated by syntax in Table~\ref{tab:syntax} is \emph{well-formed} if all the following conditions hold:
	\item \textbf{Probability distribution:} \\ 
	$P = \langle \Pi \rangle\ \alpha \bigoplus_{i \in I} p_i : P_i \Rightarrow \Sigma_{i \in I}\ p_i = 1 \wedge p_i \geq 0\ \forall\ i \in I$
%	\item \textbf{Single-level probabilistic choice:} \\ 
%	$P = \langle \Pi \rangle\ \alpha \bigoplus_{i \in I} p_i : P_i \Rightarrow P_i \neq \langle \Pi' \rangle\ \alpha' \bigoplus_{j \in J} p_j : P_j,\ \forall\ i \in I $
%	\item \textbf{Single-level non-deterministic choice:} \\ 
%	$P = \Sigma_{i \in I} P_i \Rightarrow P_i \neq \Sigma_{j \in J} P_j,\ \forall\ i \in I$
	\item \textbf{Unique processes definitions:} \\
	$ P = \langle \Pi \rangle\ \alpha \bigoplus_{i \in I} p_i : P_i \Rightarrow \exists !\ K \triangleq P_i,\ \forall i \in I$ \\
	$ P = \Sigma_{i \in I} P_i \Rightarrow \exists !\ K \triangleq P_i,\ \forall i \in I$
	\item \textbf{Absence of internal non-determinism:} \\
	$ P = \Sigma_{i \in I} P_i \wedge P_l = \langle \Pi_l \rangle\ \alpha_l \bigoplus \dots \wedge P_r = \langle \Pi_r \rangle\ \alpha_r \bigoplus \dots \\ \Rightarrow \llbracket \Pi_l \rrbracket_\Gamma = \llbracket \neg \Pi_r \rrbracket_\Gamma \vee \alpha_l \neq \alpha_r $ \todo{troppo restrittivo}
\end{enumerate}
	%\todo[inline]{def well formed terms, alternanza nondet e prob, unique process definitions}
\end{defn}
\todo[inline]{spiegare punti delle condizioni}
% paragraph well_formedness (end)

% section syntax (end)
\subsection*{Operational semantics} % (fold)
\label{sec:semantics}

Semantics of the language is given by means of transition relations $\xmapsto{\cdot}_{\cdot}\ \subseteq Proc \times PAct \times (\mathcal{A} \hookrightarrow \mathcal{V}) \times Dist(Proc)$ and $\xrightarrow{\cdot}\ \subseteq Comp \times CAct \times Dist(Comp)$ defined respectively in Table~\ref{tab:process_semantics} and Table~\ref{tab:component_semantics}. $PAct$ and $CAct$ are respectively sets of actions at the process level and at the component level, the former is generated by the syntactic category $\alpha$ while the latter is the set $Act$ extended to $a$ actions to receive and $\overline{a}$ to send, formally $CAct = \{\overline{a}\ |\ a \in Act\} \cup Act$ \todo{definire insieme Act}. Relation $\xmapsto{\cdot}_{\cdot}$ describes the probabilistic evolution of a process, while relation $\xrightarrow{\cdot}$ describes how this behavior is lifted to the component level. 

\paragraph{Process semantics} % (fold)
\label{par:process_semantics}
\begin{table}[htbp]
	\begin{center}
		$$ \textsc{(psum)}\ \frac{\Delta(P_k) = p_k \quad \llbracket \Pi \rrbracket_\Gamma \bumpeq \texttt{tt}}{\langle \Pi \rangle\ \alpha \bigoplus_{i \in I} p_i : P_i \xmapsto{\alpha}_\Gamma \Delta}\ j,k \in I $$
		$$ \textsc{(sum)}\ \frac{ P_j \xmapsto{\alpha}_\Gamma \Delta}{ \Sigma_{i \in I} P_i \xmapsto{\alpha}_\Gamma \Delta }\ j \in I \qquad \textsc{(rec)}\ \frac{ P \xmapsto{\alpha}_\Gamma \Delta \quad K \triangleq P}{ K \xmapsto{\alpha}_\Gamma \Delta } $$
	\end{center}
	\caption{Operational semantics for processes}
	\label{tab:process_semantics}
\end{table}
%
Rules in Table~\ref{tab:process_semantics} describes the processes' behaviors, we use $\Delta \in Dist(Proc)$ to denote a distribution of processes.

Rule \textsc{(psum)} puts together guard evaluation, action prefixing and probabilistic choice. If the guard is satisfied then the process can evolve performing a process action $\alpha$ into a process $P_i$ with the given probability $p_i$. Probabilities needs to respect Definition~\ref{def:wellformedness} in order to be well-formed and to guarantee a correct construction of a probability distribution.
\todo[inline]{Aggiornare semantica PSUM a PP}

Rule \textsc{(sum)} is the non-deterministic choice among a sumet of processes $\{P_i\}_{i \in I}$ that are enabled to perform some action. The process distribution $\Delta$ that a process $P$ would reach performing an action $\alpha$ is the same $\Delta$ that is reached when $P$ is inside a sum and the same action $\alpha$ is executed. This is true in absence of internal non-determinism, that is one of the assumptions of well-formedness in Definition~\ref{def:wellformedness}.

Rule \textsc{(rec)} is the standard recursive call. Since we assume that every 
process $K$ has one and only one process definition $K \triangleq P$ we cannot have ambiguities in recursive calls.
% paragraph process_semantics (end)

\paragraph{Component semantics} % (fold)
\label{par:component_semantics}

Rules in Table~\ref{tab:component_semantics} describe the semantics of components and how to lift a process behavior to the component level, we use $\Theta \in Dist(Comp)$ to denote a distribution of components.

\begin{table}[htbp]
	\begin{center}
		$$ \textsc{(lift1)}\ \frac{ P \xmapsto{\Pi(a)[\sigma]}_\Gamma \Delta \quad \Gamma' = [[\sigma]]_\Gamma \quad \Theta(\Gamma' : P') = \Delta(P')}{ \Gamma : P \xrightarrow{a} \Theta }$$
		$$
		\textsc{(lift2)}\ \frac{ P \xmapsto{(a)@\Pi[\sigma]}_\Gamma \Delta \quad \Gamma' = [[\sigma]]_\Gamma \quad \Theta(\Gamma' : P') = \Delta(P') }{ \Gamma : P \xrightarrow{\overline{a}} \Theta } $$
		$$ \textsc{(sync)}\ \frac{ C_1 \xrightarrow{a} \Theta_1 \quad C_2 \xrightarrow{a} \Theta_2}{C_1 || C_2 \xrightarrow{a} \mathscr{P}(\Theta_1, \Theta_2)} \qquad \textsc{(rcv)}\ \frac{ C_1 \xrightarrow{\overline{a}} \Theta_1 \quad C_2 \xrightarrow{a} \Theta_2}{C_1 || C_2 \xrightarrow{\overline{a}} \ \mathscr{P}(\Theta_1, \Theta_2)} $$
		$$ \textsc{(obs1)}\ \frac{ C_1 \xrightarrow{a} \Theta_1 \quad C_2 \xrightarrow{a} \Theta_2 }{ C_1 \triangleright^f C_2 \xrightarrow{a} \mathscr{O}(\Theta_1,f,\Theta_2)} \quad \textsc{(obs2)}\ \frac{ C_1 \xrightarrow{\overline{a}} \Theta_1 \quad C_2 \xrightarrow{a} \Theta_2 }{ C_1 \triangleright^f C_2 \xrightarrow{\overline{a}} \mathscr{O}(\Theta_1,f,\Theta_2)}$$
	\end{center}
	\caption{Operational semantics for components}
	\label{tab:component_semantics}
\end{table}

\todo[inline]{SYNC e RCV possono essere modellate in termini di OBS1 e OBS2 usando una funzione filtro che nasconde tutto}

Rules \textsc{(lift1)} and \textsc{(lift2)} are the basic rules that lift the process transition relation $\mapsto$ to the component transition relation $\rightarrow$. If a process $P$ with attribute environment $\Gamma$ executes an action and evolves into a process distribution $\Delta$ then the component $\Gamma : P$ can evolve into the component distribution $\Theta$ that is built by extending $\Delta$ with $\Theta(\Gamma' : P') = \Delta(P')$. When the action performed by the process $P$ is of the form $\Pi(a)[\sigma]$ then the label of the component action is $a$, while when the action is of the form $(a)@\Pi[\sigma]$ the component action is the complementary, namely $\overline{a}$. Action $a$ is intended as a \emph{receive} and $\overline{a}$ as a \emph{send}.

Rule \textsc{(sync)} is the synchronization on the same input action $a$ of two processes that can receive the same action. Let $\Theta_1, \Theta_2 \in Dist(Comp)$ be two distributions of components, then $\mathscr{P}(\Theta_1, \Theta_2) \in Dist(Comp)$ is again a distribution of components built as follows
$$
\mathscr{P}(\Theta_1, \Theta_2)(C) = \left\{
\begin{array}{ll}
	\Theta_1(C_1) \cdot \Theta_2(C_2) & \text{if } C = C_1 || C_2 \\
	0 & \text{otherwise} \\
\end{array}
\right.
$$

Rule \textsc{(rcv)} describe the communication between two components that perform complementary actions $a$ and $\overline{a}$. The probabilistic evolution is represented by distribution $\mathscr{P}(\Theta_1, \Theta_2)$ as in rule \textsc{(sync)}. 

Rule \textsc{(obs)} describe an observation made by the left-hand side component $C_1$ on the right-hand side component $C_2$. This happens when $C_2$, the observed environment, can perform an action $a$ \todo{entrambe send e receive?} and evolve into a component distribution $\Theta \in Dist(Comp)$. The observation composition of $C_1$ and $C_2$ evolves then into the component distribution $\mathscr{O}(\Theta_1,f,\Theta_2) \in Dist(Comp)$ defined as follows (operator $\bullet: Comp \times (\mathcal{A} \hookrightarrow \mathcal{V})$ is defined in Table~\ref{tab:apply_attribute_environment})
$$ 
\mathscr{O}(\Theta_1,f,\Theta_2)(C) = \left\{
%\Theta_{1\triangleright^f 2} (C) = \left\{
\begin{array}{ll}
	\Theta_1(C_1) \cdot \Theta_2(C_2) & \text{if } C = C_1 \bullet f(C_2) \triangleright^f C_2 \\
	0 & \text{otherwise} \\
\end{array}
\right.
$$

\begin{table}[htbp]
		$$ 
			C \bullet \Gamma = \left\{ 
			\begin{array}{ll}
				\Gamma' \circ \Gamma:P & \text{if } C = \Gamma' : P \\[5px]
				C_1 \bullet \Gamma\ ||\ C_2 \bullet \Gamma & \text{if } C = C_1\ ||\ C_2 \\[5px]
				C_1 \bullet \Gamma \triangleright^f C_2 \bullet \Gamma & \text{if } C = C_1 \triangleright^f C_2 \\
			\end{array}
			\right.
		$$
	\caption{Inductive definition of an attribute environment applied to a component}
	\label{tab:apply_attribute_environment}
\end{table}

% paragraph component_semantics (end)

% section semantics (end)

\section{Case studies} % (fold)
\label{sec:case_studies}

\paragraph{Swarm robotics} % (fold)
\label{par:swarm_robotics}
A collection of robots have to detect the position of a victim of an accident. The idea to approach such a problem \todo{citare paper yehia e paper margheri} is to give the same behavior to every robot. The representative behavior is initialized consists in moving around the area at random until the victim is found, then the state switch to \emph{rescuer}

Component $\Gamma_R : P_R$ represents a robot by means of its attribute environment $\Gamma_R$ and its behavior defined by process $P_R$. The observed environment is represented by the single component $\Gamma_V : P_V$ that is the victim. The system can be defined as the parallel composition of many robots that observe the victim component, formally:

$$ \Gamma_R : P_R || \dots || \Gamma_R : P_R \triangleright^f \Gamma_V : P_V $$

Every robot component knows its position that is stored in the local attribute $loc$. Local attribute $vPos$ is used to store the victim's position and it is initially set to a $null$ value to say that this information is not known yet. 

$$ 
\begin{array}{rcl}
	\Gamma_R &\triangleq& \{ pos \leftarrow 2, victimPerceived \leftarrow \texttt{ff} \} \\
	P_R &\triangleq& \overline{move}\ [this.pos \leftarrow next(this.pos)].P_R \\
	&+& obs\ [this.victimPerceived \leftarrow \texttt{tt}, this.vPos \leftarrow fvPos].P_R\\
	&+& \langle this.victimPerceived = \texttt{tt} \rangle P_{res} \\
	P_{res} &\triangleq& \dots \\[5px]
	\Gamma_V &\triangleq& \{vPos \leftarrow 5\} \\
	P_V &\triangleq&  \overline{obs}.P_V \\[5px]
\end{array}
$$

$$ 
\begin{array}{rcl}
	f(\{vPos,\dots\} : P) &=& [ 1/3 : \{fvPos \leftarrow vPos \}, \\
	&& 1/3 : \{fvPos \leftarrow vPos + 1\}, \\
	&& 1/3 : \{fvPos \leftarrow vPos - 1\} ] \\
\end{array}
$$
% paragraph swarm_robotics (end)

\paragraph{Cloud computing} % (fold)
\label{par:cloud_computing}
.
\todo[inline]{citare lavoro SCEL}
$$ \Gamma_g : S_g || \Gamma_s : S_s || \Gamma_b : S_b \triangleright^f C_1 || \dots || C_n $$
Components:
$$ 
\begin{array}{rcl}
	S_g &\triangleq& \langle workload(g,s,b) < 40\% \rangle\ gReq[g\leftarrow g+1]. S_g \\
	&+& \langle workload(g,s,b) < 80\% \rangle\ sReq[s\leftarrow s+1]. S_g \\
	&+& \langle workload(g,s,b) < 90\% \rangle\ bReq[b\leftarrow b+1]. S_g \\
	&+& \overline{gServ}[g\leftarrow g-1]. S_g \\
	&+& \overline{sServ}[s\leftarrow s-1]. S_g \\
	&+& \overline{bServ}[b\leftarrow b-1]. S_g \\

	S_s &\triangleq& \dots \\

	S_b &\triangleq& \dots \\[5px]

	\Gamma_g &\triangleq& \{g \leftarrow 0, s \leftarrow 0, b \leftarrow 0\} \\
	\Gamma_s &\triangleq& \{g \leftarrow 0, s \leftarrow 0 \} \\
	\Gamma_b &\triangleq& \{g \leftarrow 0 \} \\[5px]

	C_i &\triangleq& \emptyset : P_i \\

	P_i &\triangleq& \tau.( p: \overline{gReq}.P_i,
	q: \overline{sReq}.P_i, 1-p-q: \overline{bReq}.P_i) \\[5px]

\end{array}
$$

$$ 
\begin{array}{rcl}
	
\end{array}
$$


% paragraph cloud_computing (end)

\bibliographystyle{plain}
%\bibliography{biblio}

\end{document}